# Pumble MCP Server - Cursor Rules

## Project Overview
This is a Model Context Protocol (MCP) server for Pumble built with TypeScript. It uses ES modules, pnpm for package management, and follows strict TypeScript conventions.

## Code Style & Conventions

### TypeScript
- Use strict TypeScript settings (already configured)
- Prefer explicit types over `any`
- Use ES2022 features and syntax
- Use ES modules (`import`/`export`) - no CommonJS
- Enable all TypeScript strict checks

### File Organization
- Source code goes in `src/`
- Compiled output goes to `dist/` (do not commit)
- Use descriptive file and function names
- Group related functionality into modules/files
- Keep the main server logic in `src/index.ts` or split into logical modules

### Code Patterns

#### MCP Server Implementation
- Follow the MCP SDK patterns for tool registration
- Use async/await for all asynchronous operations
- Handle errors gracefully with proper error messages
- Return structured responses according to MCP schema
- Use `console.error` for server logs (stdio transport)
- Use `console.log` sparingly (may interfere with MCP protocol)

#### Error Handling
- Always provide meaningful error messages
- Use try-catch blocks for async operations
- Throw errors with descriptive messages for unknown tools/operations
- Log errors to stderr using `console.error`

#### Tool Implementation
- Define clear input schemas with proper types
- Validate input parameters
- Return content in the format: `{ content: [{ type: "text", text: "..." }] }`
- Use descriptive tool names (snake_case)
- Provide comprehensive tool descriptions

### Naming Conventions
- Files: kebab-case (e.g., `pumble-client.ts`)
- Functions/Methods: camelCase
- Classes: PascalCase
- Constants: UPPER_SNAKE_CASE
- Tool names: snake_case (MCP convention)

## Development Workflow

### Package Management
- Use `pnpm` for all package operations
- Run `pnpm install` after adding dependencies
- Check `pnpm-lock.yaml` into version control

### Building & Running
- Development: `pnpm dev` (uses tsx for direct TypeScript execution)
- Build: `pnpm build` (compiles TypeScript to dist/)
- Production: `pnpm start` (runs compiled code from dist/)
- Watch: `pnpm watch` (auto-rebuild on changes)

### Testing
- Write tests for new tools and functionality
- Test error cases and edge cases
- Verify MCP protocol compliance

## Best Practices

### When Adding New Tools
1. Define the tool schema with proper input validation
2. Implement the handler in `CallToolRequestSchema`
3. Register the tool in `ListToolsRequestSchema`
4. Handle errors appropriately
5. Return properly formatted responses

### When Modifying Existing Code
- Maintain backward compatibility when possible
- Update related documentation
- Test thoroughly before committing
- Follow existing code patterns

### Code Quality
- Keep functions focused and single-purpose
- Avoid deep nesting (max 3-4 levels)
- Use meaningful variable names
- Add comments for complex logic
- Keep functions reasonably sized (< 50 lines when possible)

## Dependencies
- Primary: `@modelcontextprotocol/sdk` - MCP SDK
- Development: `typescript`, `tsx`, `@types/node`
- Prefer minimal dependencies - only add what's necessary

## Git & Version Control
- Commit compiled `dist/` files if needed for distribution
- Keep `node_modules/` and `pnpm-lock.yaml` committed
- Write clear commit messages
- Keep commits focused and atomic

## Performance Considerations
- Keep tool handlers efficient
- Avoid blocking operations
- Use async/await properly
- Consider caching for expensive operations

## Security
- Validate all input parameters
- Sanitize user inputs when necessary
- Don't expose sensitive information in error messages
- Follow security best practices for API integrations

## Documentation
- Update README.md when adding significant features
- Document tool parameters and return values
- Include usage examples for new tools
- Keep code comments concise but helpful

